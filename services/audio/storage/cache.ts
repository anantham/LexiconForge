/**\n * Cache Storage for transparent audio caching\n * \n * Works with Service Worker to cache audio on first play without extra bandwidth.\n * Provides fallback when OPFS is not available.\n */\n\nexport const CacheStore = {\n  kind: 'cache' as const,\n  name: 'ost-v1',\n\n  /**\n   * Check if Cache Storage is available\n   */\n  isSupported(): boolean {\n    return typeof caches !== 'undefined';\n  },\n\n  /**\n   * Open the OST cache\n   */\n  async openCache(): Promise<Cache> {\n    if (!this.isSupported()) {\n      throw new Error('Cache Storage not available');\n    }\n    return await caches.open(this.name);\n  },\n\n  /**\n   * Check if a URL is cached\n   */\n  async has(url: string): Promise<boolean> {\n    try {\n      const cache = await this.openCache();\n      const response = await cache.match(url);\n      return !!response;\n    } catch {\n      return false;\n    }\n  },\n\n  /**\n   * Get cached response as a Blob\n   */\n  async openBlob(url: string): Promise<Blob> {\n    const cache = await this.openCache();\n    const response = await cache.match(url);\n    \n    if (!response) {\n      throw new Error('Audio not found in cache');\n    }\n    \n    return await response.blob();\n  },\n\n  /**\n   * Get cached response\n   */\n  async get(url: string): Promise<Response | undefined> {\n    const cache = await this.openCache();\n    return await cache.match(url);\n  },\n\n  /**\n   * Manually add a response to cache (usually handled by Service Worker)\n   */\n  async put(url: string, response: Response): Promise<void> {\n    const cache = await this.openCache();\n    await cache.put(url, response);\n  },\n\n  /**\n   * Remove from cache\n   */\n  async remove(url: string): Promise<boolean> {\n    try {\n      const cache = await this.openCache();\n      return await cache.delete(url);\n    } catch {\n      return false;\n    }\n  },\n\n  /**\n   * List all cached URLs\n   */\n  async listUrls(): Promise<string[]> {\n    try {\n      const cache = await this.openCache();\n      const requests = await cache.keys();\n      return requests.map(req => req.url);\n    } catch {\n      return [];\n    }\n  },\n\n  /**\n   * Get cache usage information\n   */\n  async getUsage(): Promise<{ files: number; totalSize: number }> {\n    try {\n      const cache = await this.openCache();\n      const requests = await cache.keys();\n      let totalSize = 0;\n      \n      for (const request of requests) {\n        const response = await cache.match(request);\n        if (response) {\n          const blob = await response.blob();\n          totalSize += blob.size;\n        }\n      }\n      \n      return { files: requests.length, totalSize };\n    } catch {\n      return { files: 0, totalSize: 0 };\n    }\n  },\n\n  /**\n   * Clear all cached audio\n   */\n  async clear(): Promise<void> {\n    if (!this.isSupported()) return;\n    \n    try {\n      await caches.delete(this.name);\n    } catch (error) {\n      console.warn('Failed to clear audio cache:', error);\n    }\n  },\n\n  /**\n   * Generate a cache-friendly URL for a given audio source\n   */\n  getCacheUrl(originalUrl: string): string {\n    // Normalize URL for consistent caching\n    try {\n      const url = new URL(originalUrl);\n      return url.href;\n    } catch {\n      return originalUrl;\n    }\n  }\n};