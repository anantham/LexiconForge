/**\n * Audio Pinning Service - Move audio from Cache to OPFS for long-term storage\n * \n * Handles the \"Pin\" operation that moves frequently accessed audio from\n * the temporary cache to permanent OPFS storage.\n */\n\nimport { OPFS } from './opfs';\nimport { CacheStore } from './cache';\nimport type { AudioManifest } from '../../../types';\nimport { sha256Hex, generateManifestId } from './utils';\n\nexport class AudioPinningService {\n  /**\n   * Pin cached audio to OPFS for long-term storage\n   */\n  static async pinCachedAudio(\n    cacheUrl: string, \n    chapterId: string,\n    provider: any,\n    taskType: any,\n    cost: number,\n    durationSec: number,\n    mime = 'audio/mpeg'\n  ): Promise<AudioManifest> {\n    if (!OPFS.isSupported()) {\n      throw new Error('OPFS not available - cannot pin audio');\n    }\n\n    // Get cached response\n    const cache = await CacheStore.openCache();\n    const cachedResponse = await cache.match(cacheUrl);\n    \n    if (!cachedResponse) {\n      throw new Error('Audio not found in cache - cannot pin');\n    }\n\n    const blob = await cachedResponse.blob();\n    const hash = await sha256Hex(blob);\n    \n    // Save to OPFS\n    const { uri, size } = await OPFS.save(blob, mime);\n    \n    // Create manifest\n    const manifest: AudioManifest = {\n      id: generateManifestId(chapterId, hash),\n      chapterId,\n      uri,\n      mime,\n      durationSec,\n      size,\n      hash,\n      pinned: true,\n      createdAt: Date.now(),\n      lastPlayedAt: Date.now(),\n      provider,\n      taskType,\n      cost,\n    };\n\n    return manifest;\n  }\n\n  /**\n   * Unpin audio - remove from OPFS but keep in cache\n   */\n  static async unpinAudio(manifest: AudioManifest): Promise<void> {\n    if (manifest.uri.startsWith('opfs://')) {\n      await OPFS.remove(manifest.uri);\n    }\n  }\n\n  /**\n   * Get a playable URL for audio (OPFS file or cache URL)\n   */\n  static async getPlayableUrl(manifest: AudioManifest): Promise<string> {\n    if (manifest.uri.startsWith('opfs://')) {\n      try {\n        const file = await OPFS.open(manifest.uri);\n        return URL.createObjectURL(file);\n      } catch (error) {\n        console.warn('Failed to open OPFS file, trying cache fallback:', error);\n        // If OPFS fails, try to find in cache\n        // This requires reconstructing the original URL, which we'd need to store\n        throw new Error('OPFS file not accessible and no cache fallback URL available');\n      }\n    } else if (manifest.uri.startsWith('cache://')) {\n      // Extract original URL from cache URI\n      const originalUrl = manifest.uri.replace('cache://', '');\n      \n      try {\n        const blob = await CacheStore.openBlob(originalUrl);\n        return URL.createObjectURL(blob);\n      } catch (error) {\n        throw new Error(`Cached audio not accessible: ${error.message}`);\n      }\n    }\n    \n    // Direct URL (not cached/pinned)\n    return manifest.uri;\n  }\n\n  /**\n   * Clean up object URLs to prevent memory leaks\n   */\n  static revokeObjectUrl(url: string): void {\n    if (url.startsWith('blob:')) {\n      URL.revokeObjectURL(url);\n    }\n  }\n\n  /**\n   * Check if audio is available (either pinned in OPFS or cached)\n   */\n  static async isAudioAvailable(manifest: AudioManifest): Promise<boolean> {\n    if (manifest.uri.startsWith('opfs://')) {\n      return await OPFS.exists(manifest.uri);\n    } else if (manifest.uri.startsWith('cache://')) {\n      const originalUrl = manifest.uri.replace('cache://', '');\n      return await CacheStore.has(originalUrl);\n    }\n    \n    // Direct URL - assume available (would need network check)\n    return true;\n  }\n}