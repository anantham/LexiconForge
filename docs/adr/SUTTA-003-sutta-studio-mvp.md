# SUTTA-003: Sutta Studio MVP + Deep Loom IR + Compiler Pipeline

**Date:** 2026-01-26  
**Status:** Accepted  
**Authors:** Aditya + Codex

## Context

LexiconForge currently renders chapters in a “Reader” mode optimized for flow reading.  
We want a dedicated full-screen **Sutta Studio** for embodied study of the Dhamma:

- quiet UI, minimal chrome
- polysemy is a first-class feature (click words → rotate senses)
- English scaffolding (“ghost words”) is shown as a UI artifact, not source truth
- morphology is visible on interaction (word parts + inflection cues)
- grammar relations appear on interaction, not constantly

InterfaceIdea proved the UI mechanics with a static dataset, but the dataset must become dynamic:
- SuttaCentral is canonical
- analysis is generated by an LLM pipeline into a structured IR
- IR can be rerun later as models improve

## Goals (MVP)

- Dedicated `/sutta/:uid` route (full-screen, scrollable, calm).
- SuttaCentral only (no general chapter support yet).
- English visible by default.
- Ghost words always visible at ~30% opacity, non-selectable.
- Polysemy rotator + ripple adjustments always enabled.
- Morphology segmentation included (even if imperfect).
- Grammar palette + relation tethers behind a single toggle (default ON).
- Replace hardcoded DATASET with a loader that consumes IR JSON.

## Non-Goals (Deferred)

- Always-on grammar graphs
- “Biological jigsaw” connector shapes
- Automated citation retrieval (store citation IDs only)
- Cross-sutta linking / parallels map
- Multi-chapter stitching and retrieval augmentation

## Decision

### UI Integration
- Implement Sutta Studio as a dedicated route: `/sutta/:uid`.
- Reader may provide a minimal entry point (“Open in Sutta Studio”) later.
- No settings gear in the MVP. One toggle only (unlabeled).

### Data Model
- **Hybrid IR**:
  - Canonical source segments keyed to SuttaCentral segment IDs (immutable text).
  - Derived “phase views” (Deep Loom) for UI rendering.
- IR is embedded inside Chapter records (MVP).
- Citations live in a separate registry; senses reference citation IDs.

### LLM Pipeline
Use CSP-style compiler pipeline:  
**Skeleton → Phase Deltas → Validator**

1) **Skeleton pass**: phases, anchors, ghost scaffolding, rough senses.  
2) **Phase deltas**: segmentation, senses, relations, ripple rules.  
3) **Validator**: repair references, enforce schema, list unresolved.

## Options Considered

### UI Location
A) Embed in Reader  
Pros: fewer routes  
Cons: overwhelms flow reading  

B) Reader mode toggle  
Pros: single page  
Cons: still mixes “study cockpit” into reading  

C) Dedicated route (Chosen)  
Pros: clean separation; studio can be bold without clutter  
Cons: requires routing + loader

### IR Shape
A) Phase-first only (mirror UI)  
Pros: fastest to ship  
Cons: poor canonical alignment; hard to reuse  

B) Segment-first only (canonical)  
Pros: stable  
Cons: UI projection is harder  

C) Hybrid (Chosen)  
Pros: stable source alignment + UI-friendly derived views  
Cons: needs projection + mapping metadata

### Pipeline Shape
A) Single-pass compilation  
Pros: simplest  
Cons: weaker coherence, harder to debug  

B) Skeleton → Deltas → Validator (Chosen)  
Pros: coherent, incremental, debuggable, rerunnable  
Cons: more orchestration  

C) Clause microcalls + linker  
Pros: maximum control  
Cons: expensive and complex for MVP

## Consequences

### Positive
- Minimal, elegant study experience without cluttering the main reader.
- IR can be regenerated as models improve.
- Pipeline is incremental and debuggable.

### Negative
- Chapter schema grows; export/import may require a migration path.
- MVP is limited to SuttaCentral.
- Embedded IR increases chapter payload size.

## Implementation Plan (MVP)

1) Add `/sutta/:uid` route and mount the Sutta Studio engine.  
2) Modularize InterfaceIdea into reusable components and types.  
3) Add IR loader (embedded in Chapter) and render the derived phase view.  
4) Stub compiler pipeline (skeleton → deltas → validator) for later connection.  

## Risks & Mitigations

- **Coherence drift across incremental calls**  
  Mitigate with CSP + validator pass.

- **Hallucinated citations**  
  Store only citation IDs; retrieval is a later pass.

- **Latency/cost**  
  Cache compiled packets and rerun only when needed.

## Success Criteria (MVP)

- A SuttaCentral sutta renders in Sutta Studio with:
  - Pali line, English scaffold, polysemy rotator + ripples.
  - Ghost words always visible at ~30% opacity.
  - Grammar toggle reveals suffix coloring, tooltips, and relation tethers.
- IR is dynamically loaded (not hardcoded), and rerunnable later by compiler version.

## Related Docs
- `interfaceIdea.tsx` (prototype UI)
- `docs/sutta-studio/IR.md`
- `docs/ARCHITECTURE.md`
- `docs/WORKLOG.md`

---

## Amendment — 2026-01-28: Assembly-Line Compiler & Phase State Envelope

**Status:** Accepted  
**Authors:** Aditya + Codex  
**Scope:** Compiler pipeline + prompt contracts (quality-first rework)

### Rationale
The current phase pass asks the model to segment, define, weave English, and layout in one call. This overloads small/fast models and suppresses polysemy. We adopt a sequential assembly-line pipeline that isolates roles, preserves ambiguity, and keeps JSON outputs small and strict.

### Decision
#### Pipeline Shape (updated)
Replace "Skeleton → Phase Deltas → Validator" with:
1) **Skeleton (chunked)**: phase segmentation only, using 50‑segment windows to avoid truncation.  
2) **Anatomist**: Pali word segmentation + morphology + relations (no meanings, no English).  
3) **Lexicographer**: contextual senses only (content words = 3 senses, function words = 1–2).  
4) **Weaver**: English mapping only (token-indexed, ghost words permitted).  
5) **Typesetter**: layoutBlocks only (uses relations + englishStructure).  
6) **Validator**: full schema validation after Lexicographer/Weaver, with light checks between passes.

#### Prompt Discipline
- All passes include a **Phase State Envelope** (plain text) stating current stage, completed steps, and invariants.  
- Each pass is a single‑role specialist; no parallelization (sequential handoff only).  
- Output format uses **JSON Schema structured outputs**; Zod is used only for developer ergonomics (converted to JSON Schema).

#### Schema & Data Contract Updates
- **Flatten Pass A**: separate `words`, `segments`, `relations` arrays to lower JSON nesting and error rate.  
- **Surface consistency rule**: concatenated segments must equal surface text exactly.  
- **Polysemy contract**: content words always return 3 senses; function words return 1–2.  
- **Ripples**: explicit `ripples` map used to override ghost words when a sense changes grammar.  
- **Weaver** consumes tokenized English input and returns token indices to prevent rewording drift.  
- **Typesetter** outputs layoutBlocks as a hint; UI keeps deterministic fallback if layout fails.

### UX Implications
- Cyclable indicator is driven by `senses.length > 1`, making polysemy visible.  
- Progress UI shows granular stages (anatomizing → glossing → weaving → typesetting).  
- Intermediate results are cached per phase to avoid wasted compute on refresh.

### Risks & Mitigations
- **Error propagation from Pass A**: add handoff confidence + segmentation flags; allow targeted re-run of failed words.  
- **Latency**: accept longer build times; surface precise progress states and cache per-pass outputs.  
- **Ghost word precision**: link ghosts to word IDs (stable), not segment IDs (fragile).

### Notes
This amendment aligns the compiler pipeline with the **Indra’s Net** vision: preserving ambiguity, revealing structure, and avoiding forced fluency. It is a deliberate shift toward depth over speed.
